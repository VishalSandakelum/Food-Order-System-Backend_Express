var j = Object.defineProperty;
var $ = (e, t) => j(e, "name", { value: t, configurable: !0 });
import { ContextTracker as U, ExternalTokenizer as Y, styleTags as z, tags as p, LRParser as q, LRLanguage as D, indentNodeProp as M, foldNodeProp as B, bracketMatchingHandle as F, LanguageSupport as J, EditorView as H, syntaxTree as I, EditorSelection as K } from "../../../editor.js";
const b = 1, L = 2, ee = 3, te = 4, ne = 5, Oe = 35, ae = 36, re = 37, le = 11, oe = 13;
function se(e) {
  return e == 45 || e == 46 || e == 58 || e >= 65 && e <= 90 || e == 95 || e >= 97 && e <= 122 || e >= 161;
}
$(se, "nameChar");
function ie(e) {
  return e == 9 || e == 10 || e == 13 || e == 32;
}
$(ie, "isSpace");
let x = null, R = null, G = 0;
function W(e, t) {
  let O = e.pos + t;
  if (R == e && G == O) return x;
  for (; ie(e.peek(t)); ) t++;
  let n = "";
  for (; ; ) {
    let a = e.peek(t);
    if (!se(a)) break;
    n += String.fromCharCode(a), t++;
  }
  return R = e, G = O, x = n || null;
}
$(W, "tagNameAfter");
function N(e, t) {
  this.name = e, this.parent = t, this.hash = t ? t.hash : 0;
  for (let O = 0; O < e.length; O++) this.hash += (this.hash << 4) + e.charCodeAt(O) + (e.charCodeAt(O) << 8);
}
$(N, "ElementContext");
const ye = new U({
  start: null,
  shift(e, t, O, n) {
    return t == b ? new N(W(n, 1) || "", e) : e;
  },
  reduce(e, t) {
    return t == le && e ? e.parent : e;
  },
  reuse(e, t, O, n) {
    let a = t.type.id;
    return a == b || a == oe ? new N(W(n, 1) || "", e) : e;
  },
  hash(e) {
    return e ? e.hash : 0;
  },
  strict: !1
}), ge = new Y((e, t) => {
  if (e.next == 60) {
    if (e.advance(), e.next == 47) {
      e.advance();
      let O = W(e, 0);
      if (!O) return e.acceptToken(ne);
      if (t.context && O == t.context.name) return e.acceptToken(L);
      for (let n = t.context; n; n = n.parent) if (n.name == O) return e.acceptToken(ee, -2);
      e.acceptToken(te);
    } else if (e.next != 33 && e.next != 63)
      return e.acceptToken(b);
  }
}, { contextual: !0 });
function Q(e, t) {
  return new Y((O) => {
    let n = 0, a = t.charCodeAt(0);
    e: for (; !(O.next < 0); O.advance(), n++)
      if (O.next == a) {
        for (let l = 1; l < t.length; l++)
          if (O.peek(l) != t.charCodeAt(l)) continue e;
        break;
      }
    n && O.acceptToken(e);
  });
}
$(Q, "scanTo");
const $e = Q(Oe, "-->"), me = Q(ae, "?>"), ce = Q(re, "]]>"), ue = z({
  Text: p.content,
  "StartTag StartCloseTag EndTag SelfCloseEndTag": p.angleBracket,
  TagName: p.tagName,
  "MismatchedCloseTag/TagName": [p.tagName, p.invalid],
  AttributeName: p.attributeName,
  AttributeValue: p.attributeValue,
  Is: p.definitionOperator,
  "EntityReference CharacterReference": p.character,
  Comment: p.blockComment,
  ProcessingInst: p.processingInstruction,
  DoctypeDecl: p.documentMeta,
  Cdata: p.special(p.string)
}), Se = q.deserialize({
  version: 14,
  states: ",SOQOaOOOrOxO'#CfOzOpO'#CiO!tOaO'#CgOOOP'#Cg'#CgO!{OrO'#CrO#TOtO'#CsO#]OpO'#CtOOOP'#DS'#DSOOOP'#Cv'#CvQQOaOOOOOW'#Cw'#CwO#eOxO,59QOOOP,59Q,59QOOOO'#Cx'#CxO#mOpO,59TO#uO!bO,59TOOOP'#C{'#C{O$TOaO,59RO$[OpO'#CoOOOP,59R,59ROOOQ'#C|'#C|O$dOrO,59^OOOP,59^,59^OOOS'#C}'#C}O$lOtO,59_OOOP,59_,59_O$tOpO,59`O$|OpO,59`OOOP-E6t-E6tOOOW-E6u-E6uOOOP1G.l1G.lOOOO-E6v-E6vO%UO!bO1G.oO%UO!bO1G.oO%dOpO'#CkO%lO!bO'#CyO%zO!bO1G.oOOOP1G.o1G.oOOOP1G.w1G.wOOOP-E6y-E6yOOOP1G.m1G.mO&VOpO,59ZO&_OpO,59ZOOOQ-E6z-E6zOOOP1G.x1G.xOOOS-E6{-E6{OOOP1G.y1G.yO&gOpO1G.zO&gOpO1G.zOOOP1G.z1G.zO&oO!bO7+$ZO&}O!bO7+$ZOOOP7+$Z7+$ZOOOP7+$c7+$cO'YOpO,59VO'bOpO,59VO'jO!bO,59eOOOO-E6w-E6wO'xOpO1G.uO'xOpO1G.uOOOP1G.u1G.uO(QOpO7+$fOOOP7+$f7+$fO(YO!bO<<GuOOOP<<Gu<<GuOOOP<<G}<<G}O'bOpO1G.qO'bOpO1G.qO(eO#tO'#CnOOOO1G.q1G.qO(sOpO7+$aOOOP7+$a7+$aOOOP<<HQ<<HQOOOPAN=aAN=aOOOPAN=iAN=iO'bOpO7+$]OOOO7+$]7+$]OOOO'#Cz'#CzO({O#tO,59YOOOO,59Y,59YOOOP<<G{<<G{OOOO<<Gw<<GwOOOO-E6x-E6xOOOO1G.t1G.t",
  stateData: ")Z~OPQOSVOTWOVWOWWOXWOiXOxPO}TO!PUO~OuZOw]O~O^`Oy^O~OPQOQcOSVOTWOVWOWWOXWOxPO}TO!PUO~ORdO~P!SOseO|gO~OthO!OjO~O^lOy^O~OuZOwoO~O^qOy^O~O[vO`sOdwOy^O~ORyO~P!SO^{Oy^O~OseO|}O~OthO!O!PO~O^!QOy^O~O[!SOy^O~O[!VO`sOd!WOy^O~Oa!YOy^O~Oy^O[mX`mXdmX~O[!VO`sOd!WO~O^!]Oy^O~O[!_Oy^O~O[!aOy^O~O[!cO`sOd!dOy^O~O[!cO`sOd!dO~Oa!eOy^O~Oy^Oz!gO~Oy^O[ma`madma~O[!jOy^O~O[!kOy^O~O[!lO`sOd!mO~OW!pOX!pOz!rO{!pO~O[!sOy^O~OW!pOX!pOz!vO{!pO~O",
  goto: "%[wPPPPPPPPPPxxP!OP!UPP!_!iP!oxxxP!u!{#R$Z$j$p$v$|PPPP%SXWORYbXRORYb_t`qru!T!U!bQ!h!YS!o!e!fR!t!nQdRRybXSORYbQYORmYQ[PRn[Q_QQkVjp_krz!R!T!X!Z!^!`!f!i!nQr`QzcQ!RlQ!TqQ!XsQ!ZtQ!^{Q!`!QQ!f!YQ!i!]R!n!eQu`S!UqrU![u!U!bR!b!TQ!q!gR!u!qQbRRxbQfTR|fQiUR!OiSXOYTaRb",
  nodeNames: "⚠ StartTag StartCloseTag MissingCloseTag StartCloseTag StartCloseTag Document Text EntityReference CharacterReference Cdata Element EndTag OpenTag TagName Attribute AttributeName Is AttributeValue CloseTag SelfCloseEndTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag DoctypeDecl",
  maxTerm: 47,
  context: ye,
  nodeProps: [
    ["closedBy", 1, "SelfCloseEndTag EndTag", 13, "CloseTag MissingCloseTag"],
    ["openedBy", 12, "StartTag StartCloseTag", 19, "OpenTag", 20, "StartTag"],
    ["isolate", -6, 13, 18, 19, 21, 22, 24, ""]
  ],
  propSources: [ue],
  skippedNodes: [0],
  repeatNodeCount: 8,
  tokenData: "Jy~R!XOX$nXY&kYZ&kZ]$n]^&k^p$npq&kqr$nrs'ssv$nvw(Zw}$n}!O,^!O!P$n!P!Q.m!Q![$n![!]0V!]!^$n!^!_3h!_!`El!`!aF_!a!bGQ!b!c$n!c!}0V!}#P$n#P#QHj#Q#R$n#R#S0V#S#T$n#T#o0V#o%W$n%W%o0V%o%p$n%p&a0V&a&b$n&b1p0V1p4U$n4U4d0V4d4e$n4e$IS0V$IS$I`$n$I`$Ib0V$Ib$Kh$n$Kh%#t0V%#t&/x$n&/x&Et0V&Et&FV$n&FV;'S0V;'S;:j3b;:j;=`&e<%l?&r$n?&r?Ah0V?Ah?BY$n?BY?Mn0V?MnO$nX$uWVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nP%dTVPOv%_w!^%_!_;'S%_;'S;=`%s<%lO%_P%vP;=`<%l%_W&OT{WOr%ysv%yw;'S%y;'S;=`&_<%lO%yW&bP;=`<%l%yX&hP;=`<%l$n_&t_VP{WyUOX$nXY&kYZ&kZ]$n]^&k^p$npq&kqr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nZ'zTzYVPOv%_w!^%_!_;'S%_;'S;=`%s<%lO%_~(^ast)c![!]*g!c!}*g#R#S*g#T#o*g%W%o*g%p&a*g&b1p*g4U4d*g4e$IS*g$I`$Ib*g$Kh%#t*g&/x&Et*g&FV;'S*g;'S;:j,W?&r?Ah*g?BY?Mn*g~)fQ!Q![)l#l#m)z~)oQ!Q![)l!]!^)u~)zOX~~)}R!Q![*W!c!i*W#T#Z*W~*ZS!Q![*W!]!^)u!c!i*W#T#Z*W~*jg}!O*g!O!P*g!Q![*g![!]*g!]!^,R!c!}*g#R#S*g#T#o*g$}%O*g%W%o*g%p&a*g&b1p*g1p4U*g4U4d*g4e$IS*g$I`$Ib*g$Je$Jg*g$Kh%#t*g&/x&Et*g&FV;'S*g;'S;:j,W?&r?Ah*g?BY?Mn*g~,WOW~~,ZP;=`<%l*gZ,eYVP{WOr$nrs%_sv$nw}$n}!O-T!O!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nZ-[YVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!a-z!a;'S$n;'S;=`&e<%lO$nZ.TW|QVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$n].tYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!a/d!a;'S$n;'S;=`&e<%lO$n]/mWdSVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$n_0b!O`S^QVP{WOr$nrs%_sv$nw}$n}!O0V!O!P0V!P!Q$n!Q![0V![!]0V!]!^$n!^!_%y!_!c$n!c!}0V!}#R$n#R#S0V#S#T$n#T#o0V#o$}$n$}%O0V%O%W$n%W%o0V%o%p$n%p&a0V&a&b$n&b1p0V1p4U0V4U4d0V4d4e$n4e$IS0V$IS$I`$n$I`$Ib0V$Ib$Je$n$Je$Jg0V$Jg$Kh$n$Kh%#t0V%#t&/x$n&/x&Et0V&Et&FV$n&FV;'S0V;'S;:j3b;:j;=`&e<%l?&r$n?&r?Ah0V?Ah?BY$n?BY?Mn0V?MnO$n_3eP;=`<%l0VX3mW{WOq%yqr4Vsv%yw!a%y!a!bEU!b;'S%y;'S;=`&_<%lO%yX4[]{WOr%ysv%yw}%y}!O5T!O!f%y!f!g6V!g!}%y!}#O;f#O#W%y#W#XAr#X;'S%y;'S;=`&_<%lO%yX5YV{WOr%ysv%yw}%y}!O5o!O;'S%y;'S;=`&_<%lO%yX5vT}P{WOr%ysv%yw;'S%y;'S;=`&_<%lO%yX6[V{WOr%ysv%yw!q%y!q!r6q!r;'S%y;'S;=`&_<%lO%yX6vV{WOr%ysv%yw!e%y!e!f7]!f;'S%y;'S;=`&_<%lO%yX7bV{WOr%ysv%yw!v%y!v!w7w!w;'S%y;'S;=`&_<%lO%yX7|V{WOr%ysv%yw!{%y!{!|8c!|;'S%y;'S;=`&_<%lO%yX8hV{WOr%ysv%yw!r%y!r!s8}!s;'S%y;'S;=`&_<%lO%yX9SV{WOr%ysv%yw!g%y!g!h9i!h;'S%y;'S;=`&_<%lO%yX9nX{WOr9irs:Zsv9ivw:Zw!`9i!`!a:x!a;'S9i;'S;=`;`<%lO9iP:^TO!`:Z!`!a:m!a;'S:Z;'S;=`:r<%lO:ZP:rOiPP:uP;=`<%l:ZX;PTiP{WOr%ysv%yw;'S%y;'S;=`&_<%lO%yX;cP;=`<%l9iX;kX{WOr%ysv%yw!e%y!e!f<W!f#V%y#V#W?f#W;'S%y;'S;=`&_<%lO%yX<]V{WOr%ysv%yw!f%y!f!g<r!g;'S%y;'S;=`&_<%lO%yX<wV{WOr%ysv%yw!c%y!c!d=^!d;'S%y;'S;=`&_<%lO%yX=cV{WOr%ysv%yw!v%y!v!w=x!w;'S%y;'S;=`&_<%lO%yX=}V{WOr%ysv%yw!c%y!c!d>d!d;'S%y;'S;=`&_<%lO%yX>iV{WOr%ysv%yw!}%y!}#O?O#O;'S%y;'S;=`&_<%lO%yX?VT{WxPOr%ysv%yw;'S%y;'S;=`&_<%lO%yX?kV{WOr%ysv%yw#W%y#W#X@Q#X;'S%y;'S;=`&_<%lO%yX@VV{WOr%ysv%yw#T%y#T#U@l#U;'S%y;'S;=`&_<%lO%yX@qV{WOr%ysv%yw#h%y#h#iAW#i;'S%y;'S;=`&_<%lO%yXA]V{WOr%ysv%yw#T%y#T#U>d#U;'S%y;'S;=`&_<%lO%yXAwV{WOr%ysv%yw#c%y#c#dB^#d;'S%y;'S;=`&_<%lO%yXBcV{WOr%ysv%yw#V%y#V#WBx#W;'S%y;'S;=`&_<%lO%yXB}V{WOr%ysv%yw#h%y#h#iCd#i;'S%y;'S;=`&_<%lO%yXCiV{WOr%ysv%yw#m%y#m#nDO#n;'S%y;'S;=`&_<%lO%yXDTV{WOr%ysv%yw#d%y#d#eDj#e;'S%y;'S;=`&_<%lO%yXDoV{WOr%ysv%yw#X%y#X#Y9i#Y;'S%y;'S;=`&_<%lO%yXE]T!PP{WOr%ysv%yw;'S%y;'S;=`&_<%lO%yZEuWaQVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$n_FhW[UVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nZGXYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!aGw!a;'S$n;'S;=`&e<%lO$nZHQW!OQVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nZHqYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_#P$n#P#QIa#Q;'S$n;'S;=`&e<%lO$nZIhYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!aJW!a;'S$n;'S;=`&e<%lO$nZJaWwQVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$n",
  tokenizers: [ge, $e, me, ce, 0, 1, 2, 3],
  topRules: { Document: [0, 6] },
  tokenPrec: 0
});
function C(e, t) {
  let O = t && t.getChild("TagName");
  return O ? e.sliceString(O.from, O.to) : "";
}
$(C, "tagName");
function P(e, t) {
  let O = t && t.firstChild;
  return !O || O.name != "OpenTag" ? "" : C(e, O);
}
$(P, "elementName$1");
function pe(e, t, O) {
  let n = t && t.getChildren("Attribute").find((l) => l.from <= O && l.to >= O), a = n && n.getChild("AttributeName");
  return a ? e.sliceString(a.from, a.to) : "";
}
$(pe, "attrName");
function v(e) {
  for (let t = e && e.parent; t; t = t.parent)
    if (t.name == "Element")
      return t;
  return null;
}
$(v, "findParentElement");
function fe(e, t) {
  var O;
  let n = I(e).resolveInner(t, -1), a = null;
  for (let l = n; !a && l.parent; l = l.parent)
    (l.name == "OpenTag" || l.name == "CloseTag" || l.name == "SelfClosingTag" || l.name == "MismatchedCloseTag") && (a = l);
  if (a && (a.to > t || a.lastChild.type.isError)) {
    let l = a.parent;
    if (n.name == "TagName")
      return a.name == "CloseTag" || a.name == "MismatchedCloseTag" ? { type: "closeTag", from: n.from, context: l } : { type: "openTag", from: n.from, context: v(l) };
    if (n.name == "AttributeName")
      return { type: "attrName", from: n.from, context: a };
    if (n.name == "AttributeValue")
      return { type: "attrValue", from: n.from, context: a };
    let s = n == a || n.name == "Attribute" ? n.childBefore(t) : n;
    return (s == null ? void 0 : s.name) == "StartTag" ? { type: "openTag", from: t, context: v(l) } : (s == null ? void 0 : s.name) == "StartCloseTag" && s.to <= t ? { type: "closeTag", from: t, context: l } : (s == null ? void 0 : s.name) == "Is" ? { type: "attrValue", from: t, context: a } : s ? { type: "attrName", from: t, context: a } : null;
  } else if (n.name == "StartCloseTag")
    return { type: "closeTag", from: t, context: n.parent };
  for (; n.parent && n.to == t && !(!((O = n.lastChild) === null || O === void 0) && O.type.isError); )
    n = n.parent;
  return n.name == "Element" || n.name == "Text" || n.name == "Document" ? { type: "tag", from: t, context: n.name == "Element" ? n : v(n) } : null;
}
$(fe, "findLocation");
const E = class E {
  constructor(t, O, n) {
    this.attrs = O, this.attrValues = n, this.children = [], this.name = t.name, this.completion = Object.assign(Object.assign({ type: "type" }, t.completion || {}), { label: this.name }), this.openCompletion = Object.assign(Object.assign({}, this.completion), { label: "<" + this.name }), this.closeCompletion = Object.assign(Object.assign({}, this.completion), { label: "</" + this.name + ">", boost: 2 }), this.closeNameCompletion = Object.assign(Object.assign({}, this.completion), { label: this.name + ">" }), this.text = t.textContent ? t.textContent.map((a) => ({ label: a, type: "text" })) : [];
  }
};
$(E, "Element");
let w = E;
const _ = /^[:\-\.\w\u00b7-\uffff]*$/;
function k(e) {
  return Object.assign(Object.assign({ type: "property" }, e.completion || {}), { label: e.name });
}
$(k, "attrCompletion");
function Z(e) {
  return typeof e == "string" ? { label: `"${e}"`, type: "constant" } : /^"/.test(e.label) ? e : Object.assign(Object.assign({}, e), { label: `"${e.label}"` });
}
$(Z, "valueCompletion");
function de(e, t) {
  let O = [], n = [], a = /* @__PURE__ */ Object.create(null);
  for (let r of t) {
    let m = k(r);
    O.push(m), r.global && n.push(m), r.values && (a[r.name] = r.values.map(Z));
  }
  let l = [], s = [], f = /* @__PURE__ */ Object.create(null);
  for (let r of e) {
    let m = n, y = a;
    r.attributes && (m = m.concat(r.attributes.map((o) => typeof o == "string" ? O.find((d) => d.label == o) || { label: o, type: "property" } : (o.values && (y == a && (y = Object.create(y)), y[o.name] = o.values.map(Z)), k(o)))));
    let S = new w(r, m, y);
    f[S.name] = S, l.push(S), r.top && s.push(S);
  }
  s.length || (s = l);
  for (let r = 0; r < l.length; r++) {
    let m = e[r], y = l[r];
    if (m.children)
      for (let S of m.children)
        f[S] && y.children.push(f[S]);
    else
      y.children = l;
  }
  return (r) => {
    var m;
    let { doc: y } = r.state, S = fe(r.state, r.pos);
    if (!S || S.type == "tag" && !r.explicit)
      return null;
    let { type: o, from: d, context: c } = S;
    if (o == "openTag") {
      let i = s, g = P(y, c);
      if (g) {
        let u = f[g];
        i = (u == null ? void 0 : u.children) || l;
      }
      return {
        from: d,
        options: i.map((u) => u.completion),
        validFor: _
      };
    } else if (o == "closeTag") {
      let i = P(y, c);
      return i ? {
        from: d,
        to: r.pos + (y.sliceString(r.pos, r.pos + 1) == ">" ? 1 : 0),
        options: [((m = f[i]) === null || m === void 0 ? void 0 : m.closeNameCompletion) || { label: i + ">", type: "type" }],
        validFor: _
      } : null;
    } else if (o == "attrName") {
      let i = f[C(y, c)];
      return {
        from: d,
        options: (i == null ? void 0 : i.attrs) || n,
        validFor: _
      };
    } else if (o == "attrValue") {
      let i = pe(y, c, d);
      if (!i)
        return null;
      let g = f[C(y, c)], u = ((g == null ? void 0 : g.attrValues) || a)[i];
      return !u || !u.length ? null : {
        from: d,
        to: r.pos + (y.sliceString(r.pos, r.pos + 1) == '"' ? 1 : 0),
        options: u,
        validFor: /^"[^"]*"?$/
      };
    } else if (o == "tag") {
      let i = P(y, c), g = f[i], u = [], T = c && c.lastChild;
      i && (!T || T.name != "CloseTag" || C(y, T) != i) && u.push(g ? g.closeCompletion : { label: "</" + i + ">", type: "type", boost: 2 });
      let V = u.concat(((g == null ? void 0 : g.children) || (c ? l : s)).map((h) => h.openCompletion));
      if (c && (g != null && g.text.length)) {
        let h = c.firstChild;
        h.to > r.pos - 20 && !/\S/.test(r.state.sliceDoc(h.to, r.pos)) && (V = V.concat(g.text));
      }
      return {
        from: d,
        options: V,
        validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/
      };
    } else
      return null;
  };
}
$(de, "completeFromSchema");
const X = /* @__PURE__ */ D.define({
  name: "xml",
  parser: /* @__PURE__ */ Se.configure({
    props: [
      /* @__PURE__ */ M.add({
        Element(e) {
          let t = /^\s*<\//.test(e.textAfter);
          return e.lineIndent(e.node.from) + (t ? 0 : e.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(e) {
          return e.column(e.node.from) + e.unit;
        }
      }),
      /* @__PURE__ */ B.add({
        Element(e) {
          let t = e.firstChild, O = e.lastChild;
          return !t || t.name != "OpenTag" ? null : { from: t.to, to: O.name == "CloseTag" ? O.from : e.to };
        }
      }),
      /* @__PURE__ */ F.add({
        "OpenTag CloseTag": /* @__PURE__ */ $((e) => e.getChild("TagName"), "OpenTag CloseTag")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/$/
  }
});
function Ve(e = {}) {
  let t = [X.data.of({
    autocomplete: de(e.elements || [], e.attributes || [])
  })];
  return e.autoCloseTags !== !1 && t.push(Te), new J(X, t);
}
$(Ve, "xml");
function A(e, t, O = e.length) {
  if (!t)
    return "";
  let n = t.firstChild, a = n && n.getChild("TagName");
  return a ? e.sliceString(a.from, Math.min(a.to, O)) : "";
}
$(A, "elementName");
const Te = /* @__PURE__ */ H.inputHandler.of((e, t, O, n, a) => {
  if (e.composing || e.state.readOnly || t != O || n != ">" && n != "/" || !X.isActiveAt(e.state, t, -1))
    return !1;
  let l = a(), { state: s } = l, f = s.changeByRange((r) => {
    var m, y, S;
    let { head: o } = r, d = s.doc.sliceString(o - 1, o) == n, c = I(s).resolveInner(o, -1), i;
    if (d && n == ">" && c.name == "EndTag") {
      let g = c.parent;
      if (((y = (m = g.parent) === null || m === void 0 ? void 0 : m.lastChild) === null || y === void 0 ? void 0 : y.name) != "CloseTag" && (i = A(s.doc, g.parent, o))) {
        let u = o + (s.doc.sliceString(o, o + 1) === ">" ? 1 : 0), T = `</${i}>`;
        return { range: r, changes: { from: o, to: u, insert: T } };
      }
    } else if (d && n == "/" && c.name == "StartCloseTag") {
      let g = c.parent;
      if (c.from == o - 2 && ((S = g.lastChild) === null || S === void 0 ? void 0 : S.name) != "CloseTag" && (i = A(s.doc, g, o))) {
        let u = o + (s.doc.sliceString(o, o + 1) === ">" ? 1 : 0), T = `${i}>`;
        return {
          range: K.cursor(o + T.length, -1),
          changes: { from: o, to: u, insert: T }
        };
      }
    }
    return { range: r };
  });
  return f.changes.empty ? !1 : (e.dispatch([
    l,
    s.update(f, {
      userEvent: "input.complete",
      scrollIntoView: !0
    })
  ]), !0);
});
export {
  Te as autoCloseTags,
  de as completeFromSchema,
  Ve as xml,
  X as xmlLanguage
};
